{ config, pkgs, lib, ... }:

let
  # Define the internal network name
  podmanNetwork = "jexactyl_net";
  
  # Configuration Constants
  # These match your network/caddy.nix definitions
  panelPort = "8081"; 
  wingsPort = "8082"; 
  
  # Paths for persistent storage
  dataDir = "/var/lib/jexactyl";
in
{
  # 1. Ensure Persistent Directories Exist
  systemd.tmpfiles.rules = [
    "d ${dataDir}/mariadb 0700 999 999 -"
    "d ${dataDir}/redis 0700 999 999 -"
    "d ${dataDir}/panel/storage 0755 1000 1000 -"
    "d ${dataDir}/panel/logs 0755 1000 1000 -"
    "d ${dataDir}/wings/config 0700 0 0 -"
    "d ${dataDir}/wings/data 0700 0 0 -"
  ];

  # 2. Create the Internal Network
  # We use a oneshot service to ensure the network exists before containers start
  systemd.services.init-jexactyl-network = {
    description = "Create Jexactyl Internal Podman Network";
    after = [ "network.target" "podman.service" ];
    requires = [ "podman.service" ];
    wantedBy = [ "multi-user.target" ];
    serviceConfig.Type = "oneshot";
    script = ''
      ${pkgs.podman}/bin/podman network exists ${podmanNetwork} || \
      ${pkgs.podman}/bin/podman network create ${podmanNetwork}
    '';
  };

  # 3. Container Definitions
  virtualisation.oci-containers.containers = {

    # --- SECURITY LAYER: Socket Proxy ---
    # Intercepts Wings -> Host communication. Denies all write access.
    jexactyl-socket-proxy = {
      image = "tecnativa/docker-socket-proxy:latest";
      environment = {
        CONTAINERS = "1"; # Allow listing
        IMAGES = "1";     # Allow listing
        NETWORKS = "1";   # Allow listing
        POST = "0";       # CRITICAL: Deny all write/state-change actions
        BUILD = "0";
        COMMIT = "0";
        EXEC = "0";
      };
      volumes = [
        "/run/podman/podman.sock:/var/run/docker.sock:ro" # Mount host socket Read-Only
      ];
      extraOptions = [ "--network=${podmanNetwork}" ];
    };

    # --- DATABASE: MariaDB ---
    jexactyl-mariadb = {
      image = "mariadb:10.5";
      environment = {
        MYSQL_DATABASE = "panel";
        MYSQL_USER = "jexactyl";
        MYSQL_PASSWORD_FILE = "/run/secrets/jexactyl_db_password";
        MYSQL_ROOT_PASSWORD_FILE = "/run/secrets/jexactyl_db_root_password";
      };
      volumes = [
        "${dataDir}/mariadb:/var/lib/mysql"
        # Secret injection via sops-nix
        "${config.sops.secrets.jexactyl_db_password.path}:/run/secrets/jexactyl_db_password:ro"
        "${config.sops.secrets.jexactyl_db_root_password.path}:/run/secrets/jexactyl_db_root_password:ro"
      ];
      extraOptions = [ "--network=${podmanNetwork}" ];
    };

    # --- CACHE: Redis ---
    jexactyl-redis = {
      image = "redis:alpine";
      volumes = [ "${dataDir}/redis:/data" ];
      extraOptions = [ "--network=${podmanNetwork}" ];
    };

    # --- APP: Jexactyl Panel ---
    jexactyl-panel = {
      image = "ghcr.io/jexactyl/jexactyl:latest";
      dependsOn = [ "jexactyl-mariadb" "jexactyl-redis" ];
      environment = {
        APP_URL = "https://panel.tongatime.us";
        APP_ENV = "production";
        APP_ENVIRONMENT_ONLY = "false";
        
        # Database Connections (Uses internal container names)
        DB_HOST = "jexactyl-mariadb";
        DB_PORT = "3306";
        DB_DATABASE = "panel";
        DB_USERNAME = "jexactyl";
        # Password injected via file read in entrypoint or similar mechanism
        # Jexactyl often expects DB_PASSWORD directly. 
        # For pure reproducibility without hardcoding, we use a wrapper or env file.
        # Here we assume the entrypoint supports _FILE or we rely on sops templates.
        
        # Redis
        CACHE_DRIVER = "redis";
        SESSION_DRIVER = "redis";
        QUEUE_DRIVER = "redis";
        REDIS_HOST = "jexactyl-redis";
      };
      volumes = [
        "${dataDir}/panel/storage:/app/var/"
        "${dataDir}/panel/logs:/app/storage/logs"
        "${dataDir}/panel/nginx:/etc/nginx/http.d/"
        # We mount the secrets env file generated by sops templates
        "${config.sops.templates."jexactyl.env".path}:/app/.env" 
      ];
      # Expose to Host Loopback for Caddy
      ports = [ "127.0.0.1:${panelPort}:80" ]; 
      extraOptions = [ "--network=${podmanNetwork}" ];
    };

    # --- DAEMON: Wings ---
    jexactyl-wings = {
      image = "ghcr.io/pterodactyl/wings:latest";
      dependsOn = [ "jexactyl-panel" "jexactyl-socket-proxy" ];
      environment = {
        TZ = "UTC";
        WINGS_UID = "0";
        WINGS_GID = "0";
        # Tell wings to talk to the proxy, NOT the raw socket
        DOCKER_HOST = "tcp://jexactyl-socket-proxy:2375";
      };
      volumes = [
        "${dataDir}/wings/config:/etc/pterodactyl"
        "${dataDir}/wings/data:/var/lib/pterodactyl"
      ];
      # Expose to Host Loopback for Caddy
      ports = [ "127.0.0.1:${wingsPort}:443" ]; 
      extraOptions = [ 
        "--network=${podmanNetwork}" 
        "--privileged" # Wings often needs privilege for nested container management
      ]; 
    };
  };

  # 4. Queue Worker (Required for emails/installs)
  systemd.services.jexactyl-queue = {
    description = "Jexactyl Queue Worker";
    after = [ "podman-jexactyl-panel.service" ];
    requires = [ "podman-jexactyl-panel.service" ];
    serviceConfig = {
      ExecStart = "${pkgs.podman}/bin/podman exec -i jexactyl-panel php artisan queue:work --queue=high,standard,low --sleep=3 --tries=3";
      Restart = "always";
    };
  };
}